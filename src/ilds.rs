// #![feature(unboxed_closures)]

/// The function `vdc_i` calculates the van der Corput sequence for a given base and scale.
///
/// Arguments:
///
/// * `k`: The parameter `k` represents the number that we want to convert to variable digit code (VDC)
/// representation.
/// * `base`: The `base` parameter represents the base of the number system being used. It determines
/// the number of unique digits that can be used to represent numbers. For example, in base 10, the
/// digits range from 0 to 9.
/// * `scale`: The `scale` parameter in the `vdc_i` function represents the power to which the `base` is
/// raised. It determines the number of digits in the resulting VDC (Van der Corput) number.
///
/// Returns:
///
/// The function `vdc_i` returns an unsigned integer value of type `usize`.
///
/// # Examples
///
/// ```
/// use lds_rs::ilds::vdc_i;
///
/// assert_eq!(vdc_i(10, 2, 2), 1);
/// assert_eq!(vdc_i(10, 2, 3), 2);
/// ```
pub const fn vdc_i(mut k: usize, base: usize, scale: u32) -> usize {
    let mut res = 0;
    let mut factor = base.pow(scale);
    while k != 0 {
        let remainder = k % base;
        factor /= base;
        k /= base;
        res += remainder * factor;
    }
    res
}

/// The `VdCorput` struct is a generator for Van der Corput sequences.
///
/// Properties:
///
/// * `count`: The `count` property represents the number of elements that have been generated from the
/// Van der Corput sequence so far.
/// * `base`: The `base` property represents the base of the Van der Corput sequence. It determines the
/// distribution of the generated numbers.
/// * `scale`: The `scale` property determines the precision of the generated Van der Corput sequence.
/// It represents the number of bits used to represent the fractional part of the sequence. A higher
/// scale value will result in a more precise sequence, but will also require more memory and
/// computation.
///
/// # Examples
///
/// ```
/// use lds_rs::VdCorput;
///
/// let mut vgen = VdCorput::new(2);
/// vgen.reseed(10);
/// let result = vgen.pop();
///
/// assert_eq!(result, 0.8125);
/// ```
#[derive(Debug)]
pub struct VdCorput {
    count: usize,
    base: usize,
    scale: u32,
}

impl VdCorput {
    /// Creates a new [`VdCorput`].
    ///
    /// The `new` function creates a new `VdCorput` struct with the specified base and scale values.
    ///
    /// Arguments:
    ///
    /// * `base`: The `base` parameter represents the base of the Van der Corput sequence. It determines the
    /// number of unique values that can be generated by the sequence.
    /// * `scale`: The `scale` parameter in the `new` function is of type `u32`, which stands for unsigned
    /// 32-bit integer. It represents the scale factor used in the `VdCorput` struct.
    ///
    /// Returns:
    ///
    /// The `new` function returns an instance of the `VdCorput` struct.
    pub const fn new(base: usize, scale: u32) -> Self {
        VdCorput {
            count: 0,
            base,
            scale,
        }
    }

    /// Returns the pop of this [`VdCorput`].
    ///
    /// The `pop` method of the [`VdCorput`] struct returns the next element in the Van der Corput
    /// sequence. It increments the `count` property of the struct and uses the `vdc_i` function to
    /// calculate the corresponding Van der Corput value based on the current count, base, and scale. In
    /// the example provided, a `VdCorput` instance is created with a base of 2 and a scale of 10. The
    /// `pop` method is then called, which returns the Van der Corput value for the current count (which
    /// is initially 0). In this case, the returned value is 512.
    ///
    /// # Examples
    ///
    /// ```
    /// use lds_rs::ilds::VdCorput;
    ///
    /// let mut vd_corput = VdCorput::new(2, 10);
    /// assert_eq!(vd_corput.pop(), 512);
    /// ```
    pub fn pop(&mut self) -> usize {
        self.count += 1;
        vdc_i(self.count, self.base, self.scale)
    }

    /// The below code is a Rust function called `reseed` that is used to reset the state of a sequence
    /// generator to a specific seed value. This allows the sequence generator to start generating the
    /// sequence from the beginning or from a specific point in the sequence, depending on the value of the
    /// seed.
    pub fn reseed(&mut self, seed: usize) {
        self.count = seed;
    }
}

// impl FnOnce<()> for VdCorput {
//     type Output = f64;
//     extern "rust-call" fn call_once(self, _arg: ()) -> Self::Output {
//         self.count += 1;
//         vdc(self.count, self.base)
//     }
// }

/// The [`Halton`] struct is a generator for the Halton sequence.
///
/// Properties:
///
/// * `vdc0`: An instance of the VdCorput struct used for generating the first dimension of the Halton
/// sequence.
/// * `vdc1`: The `vdc1` property is an instance of the [`VdCorput`] struct. It is used to generate the
/// Van der Corput sequence for the second dimension of the Halton sequence.
///
/// # Examples
///
/// ```
/// use lds_rs::ilds::Halton;
///
/// let mut hgen = Halton::new(&[2, 3], &[11, 7]);
/// hgen.reseed(0);
/// let result = hgen.pop();
///
/// assert_eq!(result[0], 1024);
/// ```
#[derive(Debug)]
pub struct Halton {
    vdc0: VdCorput,
    vdc1: VdCorput,
}

impl Halton {
    /// Creates a new [`Halton`].
    ///
    /// The `new` function creates a new `Halton` struct with specified base and scale values for two
    /// VdCorput sequences.
    ///
    /// Arguments:
    ///
    /// * `base`: The `base` parameter is an array of `usize` values that represents the base for each
    /// dimension of the Halton sequence. Each element in the `base` array corresponds to a dimension in
    /// the sequence.
    /// * `scale`: The `scale` parameter is an array of `u32` values that determine the scale or
    /// precision of the Halton sequence for each dimension. Each element in the `scale` array
    /// corresponds to a dimension in the Halton sequence. The larger the value of `scale`, the more
    /// precise the Halton sequence.
    ///
    /// Returns:
    ///
    /// The `new` function is returning an instance of the `Halton` struct.
    pub fn new(base: &[usize], scale: &[u32]) -> Self {
        Halton {
            vdc0: VdCorput::new(base[0], scale[0]),
            vdc1: VdCorput::new(base[1], scale[1]),
        }
    }

    /// The `pop` function returns an array containing the pop values of two [`Halton`] instances.
    ///
    /// Returns:
    ///
    /// An array of two `usize` values is being returned.
    pub fn pop(&mut self) -> [usize; 2] {
        [self.vdc0.pop(), self.vdc1.pop()]
    }

    /// The below code is a Rust function called `reseed` that is used to reset the state of a sequence
    /// generator to a specific seed value. This allows the sequence generator to start generating the
    /// sequence from the beginning or from a specific point in the sequence, depending on the value of the
    /// seed.
    #[allow(dead_code)]
    pub fn reseed(&mut self, seed: usize) {
        self.vdc0.reseed(seed);
        self.vdc1.reseed(seed);
    }
}
