use crate::lds::VdCorput;

/**
 * @brief Halton(n) sequence generator
 *
 */
pub struct HaltonN {
    vdcs: Vec<VdCorput>,
}

/// Halton(n) sequence generator
///
/// The [`HaltonN`] class is a sequence generator that generates points in a
/// N-dimensional space using the Halton sequence. The Halton sequence is a
/// low-discrepancy sequence that is commonly used in quasi-Monte Carlo methods.
/// It is generated by iterating over two different bases and calculating the
/// fractional parts of the numbers in those bases. The [`HaltonN`] class keeps
/// track of the current count and bases, and provides a `pop()` method that
/// returns the next point in the sequence as a `std::vector<double>`.
///
/// # Examples
///
/// ```
/// use lds_rs::HaltonN;
/// use approx_eq::assert_approx_eq;
///
/// let mut hgen = HaltonN::new(5, &[2, 3, 5, 7, 11]);
/// hgen.reseed(10);
/// for _i in 0..10 {
///     println!("{:?}", hgen.pop_vec());
/// }
/// let res = hgen.pop_vec();
///
/// assert_approx_eq!(res[0], 0.65625);
impl HaltonN {
    /// Creates a new [`HaltonN`].
    ///
    /// The `new(n: usize, base: &[usize])` is a constructor for
    /// the `Halton` class. It takes one parameter `base`, which is
    /// used as the bases for generating the HaltonN sequence.
    pub fn new(n: usize, base: &[usize]) -> Self {
        HaltonN {
            vdcs: (0..n).map(|i| VdCorput::new(base[i])).collect(),
        }
    }

    /// Returns the pop vec of this [`HaltonN`].
    ///
    /// The `pop()` function is used to generate the next value in the sequence.
    /// For example, in the [`VdCorput`] class, `pop()` increments the count and
    /// calculates the Van der Corput sequence value for that count and base. In
    /// the [`Halton`] class, `pop()` returns the next point in the Halton sequence
    /// as a `[f64; 2]`. Similarly, in the [`Circle`] class, `pop()`
    /// returns the next point on the unit circle as a `[f64; 2]`. In
    /// the [`Sphere`] class, `pop()` returns the next point on the unit sphere as a
    /// `[f64; 3]`. And in the [`Sphere3Hopf`] class, `pop()` returns
    /// the next point on the 3-sphere using the Hopf fibration as a `[f64; 4]`.
    pub fn pop_vec(&mut self) -> Vec<f64> {
        self.vdcs.iter_mut().map(|vdc| vdc.pop()).collect()
    }

    /// Reseed
    ///
    /// The `reseed(...)` function is used to reset the state of the
    /// sequence generator to a specific seed value. This allows the sequence
    /// generator to start generating the sequence from the beginning, or from a
    /// specific point in the sequence, depending on the value of the seed.
    pub fn reseed(&mut self, seed: usize) {
        for vdc in &mut self.vdcs {
            vdc.reseed(seed);
        }
    }
}
