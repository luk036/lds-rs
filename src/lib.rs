//! Low-Discrepancy Sequence (LDS) Generator
//!
//! This library implements a set of low-discrepancy sequence generators, which are used to create
//! sequences of numbers that are more evenly distributed than random numbers. These sequences are
//! particularly useful in various fields such as computer graphics, numerical integration, and
//! Monte Carlo simulations.
//!
//! The library defines several structs, each representing a different type of low-discrepancy sequence generator. The main types of sequences implemented are:
//!
//! 1. Van der Corput sequence
//! 2. Halton sequence
//! 3. Circle sequence
//! 4. Disk sequence
//! 5. Sphere sequence
//! 6. 3-Sphere Hopf sequence
//! 7. N-dimensional Halton sequence
//!
//! Each generator takes specific inputs, usually in the form of base numbers or sequences of base numbers. These bases determine how the sequences are generated. The generators produce outputs in the form of floating-point numbers or vectors of floating-point numbers, depending on the dimensionality of the sequence.
//!
//! The core algorithm used in most of these generators is the Van der Corput sequence. This sequence
//! is created by expressing integers in a given base, reversing the digits, and placing them after a
//! decimal point. For example, in base 2, the sequence would start: 1/2, 1/4, 3/4, 1/8, 5/8, and so on.
//!
//! The Halton sequence extends this concept to multiple dimensions by using a different base for each
//! dimension. The Circle and Sphere sequences use trigonometric functions to map these
//! low-discrepancy sequences onto circular or spherical surfaces.
//!
//! The library also includes utility functions and constants to support these generators. For instance, there's a list of prime numbers that can be used as bases for the sequences.
//!
//! Each generator struct has methods to produce the next value in the sequence (`pop()`) and to reset the sequence to a specific starting point (`reseed()`). This allows for flexible use of the generators in various applications.
//!
//! The purpose of this library is to provide a toolkit for generating well-distributed sequences of
//! numbers, which can be used in place of random numbers in many applications to achieve more uniform
//! coverage of a given space or surface. This can lead to more efficient and accurate results in
//! tasks like sampling, integration, and optimization.

use std::f64::consts::PI;

/// Constant for 2π
pub const TWO_PI: f64 = 2.0 * PI;

/// Van der Corput sequence function
///
/// Converts a given number `k` from base `base` to a floating point number.
///
/// # Arguments
///
/// * `k` - The number for which we want to calculate the van der Corput sequence value
/// * `base` - The base of the number system being used (defaults to 2)
///
/// # Examples
///
/// ```
/// use lds_gen::vdc;
/// assert_eq!(vdc(11, 2), 0.8125);
/// ```
pub fn vdc(k: u32, base: u32) -> f64 {
    let mut k = k;
    let mut res = 0.0;
    let mut denom = 1.0;
    let base_f64 = base as f64;

    while k != 0 {
        denom *= base_f64;
        let remainder = (k % base) as f64;
        k /= base;
        res += remainder / denom;
    }
    res
}

/// Van der Corput sequence generator
///
/// Generates the Van der Corput sequence, a low-discrepancy sequence commonly used in
/// quasi-Monte Carlo methods. The sequence is generated by iterating over a
/// base and calculating the fractional part of the number in that base.
///
/// # Examples
///
/// ```
/// use lds_gen::VdCorput;
/// let mut vgen = VdCorput::new(2);
/// vgen.reseed(0);
/// assert_eq!(vgen.pop(), 0.5);
/// assert_eq!(vgen.pop(), 0.25);
/// assert_eq!(vgen.pop(), 0.75);
/// ```
pub struct VdCorput {
    count: u32,
    base: u32,
    rev_lst: Vec<f64>,
}

impl VdCorput {
    /// Creates a new Van der Corput sequence generator with the given base
    ///
    /// # Arguments
    ///
    /// * `base` - The base of the number system (defaults to 2 if not specified)
    pub fn new(base: u32) -> Self {
        let mut rev_lst = Vec::with_capacity(64);
        let mut reverse = 1.0;
        let base_f64 = base as f64;

        for _ in 0..64 {
            reverse /= base_f64;
            rev_lst.push(reverse);
        }

        Self {
            count: 0,
            base,
            rev_lst,
        }
    }

    /// Generates the next value in the sequence
    ///
    /// Increments the count and calculates the Van der Corput sequence value
    /// for that count and base.
    pub fn pop(&mut self) -> f64 {
        self.count += 1; // ignore 0
        let mut k = self.count;
        let mut res = 0.0;
        let mut i = 0;

        while k != 0 {
            let remainder = (k % self.base) as f64;
            k /= self.base;
            if remainder != 0.0 {
                res += remainder * self.rev_lst[i];
            }
            i += 1;
        }
        res
    }

    /// Resets the state of the sequence generator to a specific seed value
    ///
    /// # Arguments
    ///
    /// * `seed` - The seed value that determines the starting point of the sequence generation
    pub fn reseed(&mut self, seed: u32) {
        self.count = seed;
    }
}

impl Default for VdCorput {
    fn default() -> Self {
        Self::new(2)
    }
}

/// Halton sequence generator
///
/// Generates points in a 2-dimensional space using the Halton sequence.
/// The Halton sequence is a low-discrepancy sequence that is often used in
/// quasi-Monte Carlo methods. It is generated by iterating over two different
/// bases and calculating the fractional parts of the numbers in those bases.
///
/// # Examples
///
/// ```
/// use lds_gen::Halton;
/// let mut hgen = Halton::new([2, 3]);
/// hgen.reseed(0);
/// let res = hgen.pop();
/// assert_eq!(res[0], 0.5);
/// assert!((res[1] - 1.0/3.0).abs() < 1e-10);
/// ```
pub struct Halton {
    vdc0: VdCorput,
    vdc1: VdCorput,
}

impl Halton {
    /// Creates a new Halton sequence generator with the given bases
    ///
    /// # Arguments
    ///
    /// * `base` - An array of two integers used as bases for generating the Halton sequence
    pub fn new(base: [u32; 2]) -> Self {
        Self {
            vdc0: VdCorput::new(base[0]),
            vdc1: VdCorput::new(base[1]),
        }
    }

    /// Generates the next point in the Halton sequence
    ///
    /// Returns the next point in the Halton sequence as a `[f64; 2]`.
    pub fn pop(&mut self) -> [f64; 2] {
        [self.vdc0.pop(), self.vdc1.pop()]
    }

    /// Resets the state of the sequence generator to a specific seed value
    ///
    /// # Arguments
    ///
    /// * `seed` - The seed value that determines the starting point of the sequence generation
    pub fn reseed(&mut self, seed: u32) {
        self.vdc0.reseed(seed);
        self.vdc1.reseed(seed);
    }
}

/// Unit Circle sequence generator
///
/// Generates points on the unit circle using a low-discrepancy sequence.
///
/// # Examples
///
/// ```
/// use lds_gen::Circle;
/// let mut cgen = Circle::new(2);
/// cgen.reseed(0);
/// let res = cgen.pop();
/// // Should be approximately [-1.0, 0.0] (cos(π), sin(π))
/// assert!((res[0] + 1.0).abs() < 1e-10);
/// assert!(res[1].abs() < 1e-10);
/// ```
pub struct Circle {
    vdc: VdCorput,
}

impl Circle {
    /// Creates a new Circle sequence generator with the given base
    ///
    /// # Arguments
    ///
    /// * `base` - The base of the Van der Corput sequence
    pub fn new(base: u32) -> Self {
        Self {
            vdc: VdCorput::new(base),
        }
    }

    /// Generates the next point on the unit circle
    ///
    /// Returns the next point on the unit circle as a `[f64; 2]`.
    pub fn pop(&mut self) -> [f64; 2] {
        let theta = self.vdc.pop() * TWO_PI; // map to [0, 2π]
        [theta.cos(), theta.sin()]
    }

    /// Resets the state of the sequence generator to a specific seed value
    ///
    /// # Arguments
    ///
    /// * `seed` - The seed value that determines the starting point of the sequence generation
    pub fn reseed(&mut self, seed: u32) {
        self.vdc.reseed(seed);
    }
}

/// Unit Disk sequence generator
///
/// Generates points in the unit disk using a low-discrepancy sequence.
///
/// # Examples
///
/// ```
/// use lds_gen::Disk;
/// let mut dgen = Disk::new([2, 3]);
/// dgen.reseed(0);
/// let res = dgen.pop();
/// // First point should be on the unit disk
/// let radius_sq = res[0] * res[0] + res[1] * res[1];
/// assert!(radius_sq <= 1.0);
/// ```
pub struct Disk {
    vdc0: VdCorput,
    vdc1: VdCorput,
}

impl Disk {
    /// Creates a new Disk sequence generator with the given bases
    ///
    /// # Arguments
    ///
    /// * `base` - An array of two integers used as bases for generating the sequence
    pub fn new(base: [u32; 2]) -> Self {
        Self {
            vdc0: VdCorput::new(base[0]),
            vdc1: VdCorput::new(base[1]),
        }
    }

    /// Generates the next point in the unit disk
    ///
    /// Returns the next point in the unit disk as a `[f64; 2]`.
    pub fn pop(&mut self) -> [f64; 2] {
        let theta = self.vdc0.pop() * TWO_PI; // map to [0, 2π]
        let radius = self.vdc1.pop().sqrt(); // map to [0, 1]
        [radius * theta.cos(), radius * theta.sin()]
    }

    /// Resets the state of the sequence generator to a specific seed value
    ///
    /// # Arguments
    ///
    /// * `seed` - The seed value that determines the starting point of the sequence generation
    pub fn reseed(&mut self, seed: u32) {
        self.vdc0.reseed(seed);
        self.vdc1.reseed(seed);
    }
}

/// Unit Sphere sequence generator
///
/// Generates points on the unit sphere using a low-discrepancy sequence.
///
/// # Examples
///
/// ```
/// use lds_gen::Sphere;
/// let mut sgen = Sphere::new([2, 3]);
/// sgen.reseed(0);
/// let res = sgen.pop();
/// // Should be on the unit sphere
/// let radius_sq = res[0] * res[0] + res[1] * res[1] + res[2] * res[2];
/// assert!((radius_sq - 1.0).abs() < 1e-10);
/// ```
pub struct Sphere {
    vdc: VdCorput,
    cirgen: Circle,
}

impl Sphere {
    /// Creates a new Sphere sequence generator with the given bases
    ///
    /// # Arguments
    ///
    /// * `base` - An array of two integers used as bases for generating the sequence
    pub fn new(base: [u32; 2]) -> Self {
        Self {
            vdc: VdCorput::new(base[0]),
            cirgen: Circle::new(base[1]),
        }
    }

    /// Generates the next point on the unit sphere
    ///
    /// Returns the next point on the unit sphere as a `[f64; 3]`.
    pub fn pop(&mut self) -> [f64; 3] {
        let cosphi = 2.0 * self.vdc.pop() - 1.0; // map to [-1, 1]
        let sinphi = (1.0 - cosphi * cosphi).sqrt(); // cylindrical mapping
        let [c, s] = self.cirgen.pop();
        [sinphi * c, sinphi * s, cosphi]
    }

    /// Resets the state of the sequence generator to a specific seed value
    ///
    /// # Arguments
    ///
    /// * `seed` - The seed value that determines the starting point of the sequence generation
    pub fn reseed(&mut self, seed: u32) {
        self.cirgen.reseed(seed);
        self.vdc.reseed(seed);
    }
}

/// Sphere-3 sequence generator using Hopf coordinates
///
/// Based on the paper:
/// Yershova, Anna, et al. "Generating uniform incremental grids on SO (3) using the Hopf fibration."
/// The International journal of robotics research 29.7 (2010): 801-812.
///
/// # Examples
///
/// ```
/// use lds_gen::Sphere3Hopf;
/// let mut sp3hgen = Sphere3Hopf::new([2, 3, 5]);
/// sp3hgen.reseed(0);
/// let res = sp3hgen.pop();
/// // Should be on the 3-sphere
/// let radius_sq = res[0] * res[0] + res[1] * res[1] + res[2] * res[2] + res[3] * res[3];
/// assert!((radius_sq - 1.0).abs() < 1e-10);
/// ```
pub struct Sphere3Hopf {
    vdc0: VdCorput,
    vdc1: VdCorput,
    vdc2: VdCorput,
}

impl Sphere3Hopf {
    /// Creates a new Sphere3Hopf sequence generator with the given bases
    ///
    /// # Arguments
    ///
    /// * `base` - An array of three integers used as bases for generating the sequence
    pub fn new(base: [u32; 3]) -> Self {
        Self {
            vdc0: VdCorput::new(base[0]),
            vdc1: VdCorput::new(base[1]),
            vdc2: VdCorput::new(base[2]),
        }
    }

    /// Generates the next point on the 3-sphere using Hopf fibration
    ///
    /// Returns the next point on the 3-sphere as a `[f64; 4]`.
    pub fn pop(&mut self) -> [f64; 4] {
        let phi = self.vdc0.pop() * TWO_PI; // map to [0, 2π]
        let psy = self.vdc1.pop() * TWO_PI; // map to [0, 2π]
        let vdc = self.vdc2.pop();
        let cos_eta = vdc.sqrt();
        let sin_eta = (1.0 - vdc).sqrt();
        [
            cos_eta * psy.cos(),
            cos_eta * psy.sin(),
            sin_eta * (phi + psy).cos(),
            sin_eta * (phi + psy).sin(),
        ]
    }

    /// Resets the state of the sequence generator to a specific seed value
    ///
    /// # Arguments
    ///
    /// * `seed` - The seed value that determines the starting point of the sequence generation
    pub fn reseed(&mut self, seed: u32) {
        self.vdc0.reseed(seed);
        self.vdc1.reseed(seed);
        self.vdc2.reseed(seed);
    }
}

/// N-dimensional Halton sequence generator
///
/// Generates points in N-dimensional space using the Halton sequence.
///
/// # Examples
///
/// ```
/// use lds_gen::HaltonN;
/// let mut hgen = HaltonN::new(&[2, 3, 5]);
/// hgen.reseed(0);
/// let res = hgen.pop();
/// assert_eq!(res[0], 0.5);
/// assert!((res[1] - 1.0/3.0).abs() < 1e-10);
/// assert!((res[2] - 0.2).abs() < 1e-10);
/// ```
pub struct HaltonN {
    vdcs: Vec<VdCorput>,
}

impl HaltonN {
    /// Creates a new N-dimensional Halton sequence generator with the given bases
    ///
    /// # Arguments
    ///
    /// * `base` - A slice of integers used as bases for each dimension
    pub fn new(base: &[u32]) -> Self {
        let vdcs = base.iter().map(|&b| VdCorput::new(b)).collect();
        Self { vdcs }
    }

    /// Generates the next point in the N-dimensional Halton sequence
    ///
    /// Returns the next point as a `Vec<f64>`.
    pub fn pop(&mut self) -> Vec<f64> {
        self.vdcs.iter_mut().map(|vdc| vdc.pop()).collect()
    }

    /// Resets the state of the sequence generator to a specific seed value
    ///
    /// # Arguments
    ///
    /// * `seed` - The seed value that determines the starting point of the sequence generation
    pub fn reseed(&mut self, seed: u32) {
        for vdc in &mut self.vdcs {
            vdc.reseed(seed);
        }
    }
}

/// First 1000 prime numbers
///
/// Can be used as bases for low-discrepancy sequences.
pub const PRIME_TABLE: [u32; 1000] = [
    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,
    101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193,
    197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307,
    311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421,
    431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547,
    557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659,
    661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,
    809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929,
    937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039,
    1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153,
    1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279,
    1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409,
    1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499,
    1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613,
    1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741,
    1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873,
    1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999,
    2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113,
    2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251,
    2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371,
    2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477,
    2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647,
    2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731,
    2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857,
    2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001,
    3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163,
    3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299,
    3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407,
    3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539,
    3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659,
    3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793,
    3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919,
    3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051,
    4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201,
    4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327,
    4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463,
    4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603,
    4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733,
    4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903,
    4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009,
    5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153,
    5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303,
    5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441,
    5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569,
    5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701,
    5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843,
    5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987,
    6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131,
    6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269,
    6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373,
    6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553,
    6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691,
    6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829,
    6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967,
    6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109,
    7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247,
    7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451,
    7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559,
    7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687,
    7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841,
    7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919,
];

/// Integer low-discrepancy sequence generators
pub mod ilds;

/// N-dimensional sphere sequence generators
pub mod sphere_n;

#[cfg(test)]
mod tests {
    use super::*;
    use approx::assert_relative_eq;

    #[test]
    fn test_vdc_function() {
        assert_eq!(vdc(11, 2), 0.8125);
        assert_eq!(vdc(0, 2), 0.0);
        assert_eq!(vdc(1, 2), 0.5);
        assert_eq!(vdc(2, 2), 0.25);
        assert_eq!(vdc(3, 2), 0.75);
    }

    #[test]
    fn test_vdcorput_pop() {
        let mut vgen = VdCorput::new(2);
        vgen.reseed(0);
        assert_eq!(vgen.pop(), 0.5);
        assert_eq!(vgen.pop(), 0.25);
        assert_eq!(vgen.pop(), 0.75);
        assert_eq!(vgen.pop(), 0.125);
    }

    #[test]
    fn test_vdcorput_reseed() {
        let mut vgen = VdCorput::new(2);
        vgen.reseed(5);
        assert_eq!(vgen.pop(), 0.375);
        vgen.reseed(0);
        assert_eq!(vgen.pop(), 0.5);
    }

    #[test]
    fn test_vdcorput_default() {
        let mut vgen = VdCorput::default();
        vgen.reseed(0);
        assert_eq!(vgen.pop(), 0.5);
        assert_eq!(vgen.pop(), 0.25);
    }

    #[test]
    fn test_halton_pop() {
        let mut hgen = Halton::new([2, 3]);
        hgen.reseed(0);
        let res = hgen.pop();
        assert_eq!(res[0], 0.5);
        assert_relative_eq!(res[1], 1.0 / 3.0, epsilon = 1e-10);

        let res = hgen.pop();
        assert_eq!(res[0], 0.25);
        assert_relative_eq!(res[1], 2.0 / 3.0, epsilon = 1e-10);
    }

    #[test]
    fn test_circle_pop() {
        let mut cgen = Circle::new(2);
        cgen.reseed(0);
        let res = cgen.pop();
        // First point should be at angle π (180 degrees)
        assert_relative_eq!(res[0], -1.0, epsilon = 1e-10);
        assert_relative_eq!(res[1], 0.0, epsilon = 1e-10);

        let res = cgen.pop();
        // Second point should be at angle π/2 (90 degrees)
        assert_relative_eq!(res[0], 0.0, epsilon = 1e-10);
        assert_relative_eq!(res[1], 1.0, epsilon = 1e-10);
    }

    #[test]
    fn test_disk_pop() {
        let mut dgen = Disk::new([2, 3]);
        dgen.reseed(0);
        let res = dgen.pop();

        // Check that point is within unit disk
        let radius_sq = res[0] * res[0] + res[1] * res[1];
        assert!(radius_sq <= 1.0);

        // Generate a few more points and check they're all within unit disk
        for _ in 0..10 {
            let res = dgen.pop();
            let radius_sq = res[0] * res[0] + res[1] * res[1];
            assert!(radius_sq <= 1.0);
        }
    }

    #[test]
    fn test_sphere_pop() {
        let mut sgen = Sphere::new([2, 3]);
        sgen.reseed(0);
        let res = sgen.pop();

        // Check that point is on unit sphere
        let radius_sq = res[0] * res[0] + res[1] * res[1] + res[2] * res[2];
        assert_relative_eq!(radius_sq, 1.0, epsilon = 1e-10);

        // Generate a few more points and check they're all on unit sphere
        for _ in 0..5 {
            let res = sgen.pop();
            let radius_sq = res[0] * res[0] + res[1] * res[1] + res[2] * res[2];
            assert_relative_eq!(radius_sq, 1.0, epsilon = 1e-10);
        }
    }

    #[test]
    fn test_sphere3hopf_pop() {
        let mut sp3hgen = Sphere3Hopf::new([2, 3, 5]);
        sp3hgen.reseed(0);
        let res = sp3hgen.pop();

        // Check that point is on 3-sphere
        let radius_sq = res[0] * res[0] + res[1] * res[1] + res[2] * res[2] + res[3] * res[3];
        assert_relative_eq!(radius_sq, 1.0, epsilon = 1e-10);

        // Generate a few more points and check they're all on 3-sphere
        for _ in 0..5 {
            let res = sp3hgen.pop();
            let radius_sq = res[0] * res[0] + res[1] * res[1] + res[2] * res[2] + res[3] * res[3];
            assert_relative_eq!(radius_sq, 1.0, epsilon = 1e-10);
        }
    }

    #[test]
    fn test_haltonn_pop() {
        let mut hgen = HaltonN::new(&[2, 3, 5]);
        hgen.reseed(0);
        let res = hgen.pop();

        assert_eq!(res[0], 0.5);
        assert_relative_eq!(res[1], 1.0 / 3.0, epsilon = 1e-10);
        assert_relative_eq!(res[2], 0.2, epsilon = 1e-10);

        let res = hgen.pop();
        assert_eq!(res[0], 0.25);
        assert_relative_eq!(res[1], 2.0 / 3.0, epsilon = 1e-10);
        assert_relative_eq!(res[2], 0.4, epsilon = 1e-10);
    }

    #[test]
    fn test_prime_table() {
        // Check first few primes
        assert_eq!(PRIME_TABLE[0], 2);
        assert_eq!(PRIME_TABLE[1], 3);
        assert_eq!(PRIME_TABLE[2], 5);
        assert_eq!(PRIME_TABLE[3], 7);
        assert_eq!(PRIME_TABLE[4], 11);

        // Check table length
        assert_eq!(PRIME_TABLE.len(), 1000);

        // Check a prime near the end
        assert_eq!(PRIME_TABLE[999], 7919);
    }
}
